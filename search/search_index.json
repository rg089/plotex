{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":""},{"location":"#creating-elegant-publication-ready-plots-made-simple","title":"Creating elegant, publication-ready plots made simple","text":"<p>Plotex is a minimal wrapper over matplotlib (and to some extent, seaborn). It is primarily designed to ease plot generation for publications by taking care of the configuration (plot size, color schemes, font type/size/weight etc.) as well as enable rapid prototyping to reduce manual effort.</p>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<p>The site is divided into the following sections:</p> <ol> <li>Snippets</li> <li>API</li> <li>Changelog</li> </ol> <p>Snippets contains examples and snippets that can be used frequently. API is the resting place for the documentation of individual classes and functions while Changelog is employed to track the added/removed functionalities in each version.</p>"},{"location":"#installation","title":"Installation","text":"<p>Run the following command for installing:</p> <pre><code>pip install plotex\n</code></pre>"},{"location":"#sample-usage","title":"Sample Usage","text":"<pre><code>from plotex import plotex\nplotex.init(colorblind=True)\n\nsubplots = (1,1)\n\nfigsize = plotex.skeleton(publisher='acl', fraction=0.5, subplots=subplots)\n\nplotex.update_textsize(legend=3, xticks=-1, yticks=1) # Defines the font offset for each element (ex. font size of legend is increased by 3 points, size of xticks is decreased by 1pt etc.)\n\nfig, axes = plt.subplots(nrows=subplots[0], ncols=subplots[1], figsize=figsize)\n\naxes.plot([1,2,3], [1,2,3], label='$y=x$')\naxes.plot([1,2,3], [1,4,9], label='$y=x^2$')\n\nplotex.set_text(ax=axes, xlabel='Values of x', ylabel='Values of y')\nplotex.save('sample.pdf', fig=fig)\n\n</code></pre>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>This project was mainly created for personal usage. I wanted a simple API where I could set a default theme once and use it repeatedly for multiple plots across various projects. I also required the ability to quickly change the font sizes/weights etc. without rewriting the same/similar lines of code over and over again. </p> <p>The references I used while writing Plotex are:</p> <ul> <li>Matplotlib</li> <li>It's more fun to compute</li> <li>Markov Wanderer</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<ul> <li>v1.0.0: Released the base version!</li> </ul>"},{"location":"frequent/","title":"Snippets","text":"<p>This part of the project documentation focuses on a problem-oriented approach. You'll tackle common tasks that you might have, with the help of the code provided in this project.</p>"},{"location":"frequent/#how-to-add-two-numbers","title":"How To Add Two Numbers?","text":"<p>You have two numbers and you need to add them together. You're in luck! The <code>calculator</code> package can help you get this done.</p> <p>Download the code from this GitHub repository and place the <code>calculator/</code> folder in the same directory as your Python script:</p> <pre><code>your_project/\n\u2502\n\u251c\u2500\u2500 calculator/\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u2514\u2500\u2500 calculations.py\n\u2502\n\u2514\u2500\u2500 your_script.py\n</code></pre> <p>Inside of <code>your_script.py</code> you can now import the <code>add()</code> function from the <code>calculator.calculations</code> module:</p> <pre><code># your_script.py\nfrom calculator.calculations import add\n</code></pre> <p>After you've imported the function, you can use it to add any two numbers that you need to add:</p> <pre><code># your_script.py\nfrom calculator.calculations import add\n\nprint(add(20, 22))  # OUTPUT: 42.0\n</code></pre> <p>You're now able to add any two numbers, and you'll always get a <code>float</code> as a result.</p>"},{"location":"api/","title":"Overview of the API","text":"<p>This part of the project documentation focuses on an information-oriented approach. Use it as a reference for the technical implementation of the <code>calculator</code> project code.</p>"},{"location":"api/#plotex.configuration","title":"<code>configuration</code>","text":""},{"location":"api/#plotex.configuration.configuration","title":"<code>configuration</code>","text":""},{"location":"api/#plotex.configuration.configuration.BackendConfiguration","title":"<code>BackendConfiguration</code>","text":"Source code in <code>plotex/configuration/configuration.py</code> <pre><code>class BackendConfiguration():\n\n    CONFIG_FILE_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"config_files/config.txt\")\n    CONFIG_URL = \"https://gist.githubusercontent.com/rg089/26d06984604c92cf452e77ee345434ea/raw/98730d2afa1be6381b4c9c0f6f18da440200fc9a/latex_plots.txt\"\n\n\n    def __init__(self, url=None, override=False, **kwargs):\n\"\"\"initializing the configuration class\n\n        Args:\n            url: the url of the config to create a new config, defaults\n                to None\n            override: if the config from the specified link already\n                exists, whether to create it again (used if in-place\n                changes have been made to the url)\n            kwargs: other keyword arguments can include arguments for theme, style, palette etc.\n        \"\"\"\n        if url is None:\n            self.url = BackendConfiguration.CONFIG_URL\n        self.override = override\n\n        self.style = None\n        self.palette = None\n        self.__init_theme(**kwargs)\n\n\n    def __fetch_content(self, url):\n\"\"\"fetches the config params from the url if not locally present\n\n        Raises:\n            Exception: if issue in fetching and decoding\n\n        Returns:\n            returns the content from the url\n        \"\"\"\n        print(f\"[INFO] Fetching configuration parameters from {url}!\")\n        try:\n            r = requests.get(url)\n            content = r.content.decode()\n        except:\n            raise Exception('An error occured while fetching and decoding the url content')\n\n        return content\n\n\n    def __generate_content_path(self):\n\"\"\"creates the config by using a cached file, or fetching from the internet if cached file not present\n\n        Returns:\n            the file path of the config file\n        \"\"\"\n        url_hash = hash_url(self.url)\n        fpath = combine_hash(BackendConfiguration.CONFIG_FILE_PATH, url_hash)\n\n        exists = check_if_exists(fpath)\n        if exists and not self.override: # If file exists and we don't need to override\n            return fpath\n\n        content = self.__fetch_content(url=self.url)\n        save_file(content=content, fpath=fpath)\n\n        return fpath\n\n\n    def __init_theme(self, **kwargs):\n        # Set style\n        self.style = find_value_from_keys(kwargs, ['style', 'theme', 'background'])\n\n        # Set palette\n        self.palette = find_value_from_keys(kwargs, ['palette', 'cmap'])\n        if self.palette is None: # If palette wasn't specified but colorblind argument is given\n            use_colorblind = find_value_from_keys(kwargs, ['colorblind', 'colourblind', 'blind'])\n            if use_colorblind:\n                self.palette = 'colorblind'\n\n\n    def reset(self):\n\"\"\"reset the parameters to the original matplotlib ones\"\"\"\n        plt.rcdefaults()\n\n\n    def initialize(self):\n\"\"\"initializes the configuration file by setting the style from the config file\"\"\"\n\n        if self.style is not None:\n            sns.set_style(self.style)\n\n        # Nothe that the settings in the config file will override the conflicting ones in the specified seaborn style\n        final_path = self.__generate_content_path()\n        plt.style.use(final_path)\n\n        if self.palette is not None:\n            sns.set_palette(self.palette)\n</code></pre>"},{"location":"api/#plotex.configuration.configuration.BackendConfiguration.__fetch_content","title":"<code>__fetch_content(url)</code>","text":"<p>fetches the config params from the url if not locally present</p> <p>Raises:</p> Type Description <code>Exception</code> <p>if issue in fetching and decoding</p> <p>Returns:</p> Type Description <p>returns the content from the url</p> Source code in <code>plotex/configuration/configuration.py</code> <pre><code>def __fetch_content(self, url):\n\"\"\"fetches the config params from the url if not locally present\n\n    Raises:\n        Exception: if issue in fetching and decoding\n\n    Returns:\n        returns the content from the url\n    \"\"\"\n    print(f\"[INFO] Fetching configuration parameters from {url}!\")\n    try:\n        r = requests.get(url)\n        content = r.content.decode()\n    except:\n        raise Exception('An error occured while fetching and decoding the url content')\n\n    return content\n</code></pre>"},{"location":"api/#plotex.configuration.configuration.BackendConfiguration.__generate_content_path","title":"<code>__generate_content_path()</code>","text":"<p>creates the config by using a cached file, or fetching from the internet if cached file not present</p> <p>Returns:</p> Type Description <p>the file path of the config file</p> Source code in <code>plotex/configuration/configuration.py</code> <pre><code>def __generate_content_path(self):\n\"\"\"creates the config by using a cached file, or fetching from the internet if cached file not present\n\n    Returns:\n        the file path of the config file\n    \"\"\"\n    url_hash = hash_url(self.url)\n    fpath = combine_hash(BackendConfiguration.CONFIG_FILE_PATH, url_hash)\n\n    exists = check_if_exists(fpath)\n    if exists and not self.override: # If file exists and we don't need to override\n        return fpath\n\n    content = self.__fetch_content(url=self.url)\n    save_file(content=content, fpath=fpath)\n\n    return fpath\n</code></pre>"},{"location":"api/#plotex.configuration.configuration.BackendConfiguration.__init__","title":"<code>__init__(url=None, override=False, **kwargs)</code>","text":"<p>initializing the configuration class</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <p>the url of the config to create a new config, defaults to None</p> <code>None</code> <code>override</code> <p>if the config from the specified link already exists, whether to create it again (used if in-place changes have been made to the url)</p> <code>False</code> <code>kwargs</code> <p>other keyword arguments can include arguments for theme, style, palette etc.</p> <code>{}</code> Source code in <code>plotex/configuration/configuration.py</code> <pre><code>def __init__(self, url=None, override=False, **kwargs):\n\"\"\"initializing the configuration class\n\n    Args:\n        url: the url of the config to create a new config, defaults\n            to None\n        override: if the config from the specified link already\n            exists, whether to create it again (used if in-place\n            changes have been made to the url)\n        kwargs: other keyword arguments can include arguments for theme, style, palette etc.\n    \"\"\"\n    if url is None:\n        self.url = BackendConfiguration.CONFIG_URL\n    self.override = override\n\n    self.style = None\n    self.palette = None\n    self.__init_theme(**kwargs)\n</code></pre>"},{"location":"api/#plotex.configuration.configuration.BackendConfiguration.initialize","title":"<code>initialize()</code>","text":"<p>initializes the configuration file by setting the style from the config file</p> Source code in <code>plotex/configuration/configuration.py</code> <pre><code>def initialize(self):\n\"\"\"initializes the configuration file by setting the style from the config file\"\"\"\n\n    if self.style is not None:\n        sns.set_style(self.style)\n\n    # Nothe that the settings in the config file will override the conflicting ones in the specified seaborn style\n    final_path = self.__generate_content_path()\n    plt.style.use(final_path)\n\n    if self.palette is not None:\n        sns.set_palette(self.palette)\n</code></pre>"},{"location":"api/#plotex.configuration.configuration.BackendConfiguration.reset","title":"<code>reset()</code>","text":"<p>reset the parameters to the original matplotlib ones</p> Source code in <code>plotex/configuration/configuration.py</code> <pre><code>def reset(self):\n\"\"\"reset the parameters to the original matplotlib ones\"\"\"\n    plt.rcdefaults()\n</code></pre>"},{"location":"api/#plotex.main","title":"<code>main</code>","text":""},{"location":"api/#plotex.main.Plotex","title":"<code>Plotex</code>","text":"<p>a facade over various different functions in the module for a direct one-point access</p> Source code in <code>plotex/main.py</code> <pre><code>class Plotex:\n\"\"\"a facade over various different functions in the module for a direct one-point access\"\"\"\n    def __init__(self, **kwargs):\n\"\"\"initialize the controller\n\n        Args:\n            **kwargs: parameters for the config file, the params include\n                `url` \\\n        (the url for the config file), `cmap/palette` for the cmap, `style/theme` \\\n        for the seaborn style\n        \"\"\"\n        init = kwargs.get('initialize', True)\n        if init:\n            self.init(**kwargs)\n\n\n    def init(self, **kwargs):\n\"\"\"initialize the controller\n\n        Args:\n            **kwargs: parameters for the config file, the params include\n                `url` \\\n        (the url for the config file), `cmap/palette` for the cmap, `style/theme` \\\n        for the seaborn style\n        \"\"\"\n        self.config = BackendConfiguration(**kwargs)\n        self.sizer = Sizing(config=self.config)\n        self.params = None\n        self.config.initialize()\n\n\n    def skeleton(self, width=None, publisher=None, width_in_pts=True, reinitialize=True, fraction=1, \n                   subplots=(1, 1), **kwargs):\n\"\"\"finds the ideal size of the plot and adjusts the text sizes according to the required dimensions\n        this is a dummy function wrapped over the `get_figure` function from Sizing to enable direct access\n\n        Args:\n            width: the width, defaults to None\n            publisher: the name of the publisher, defaults to None\n            width_in_pts: whether the width is in points, defaults to\n                True\n            reinitialize: whether to reinitialize the config to itys\n                defaults, defaults to True\n            fraction: the fraction of the width supplied to use,\n                defaults to 1\n            subplots: (nrows, ncols), defaults to (1, 1)\n\n        Returns:\n            fig, axes if return_size is False, else (width, height)\n        \"\"\"\n\n        output = self.sizer.get_size(width=width, publisher=publisher, width_in_pts=width_in_pts, reinitialize=reinitialize,\n                              fraction=fraction, subplots=subplots, **kwargs)\n        self.params = plt.rcParams.copy()\n        return output\n\n    def update_textsize(self, reinitialize=True, **kwargs):\n\"\"\"This function changes the font size of various text elements in the plot such as xlabel, \\\n        ylabel, title, ticks, etc., by a specified offset. Uses deterministic and probabilistic \\\n        matching to determine and map the keyword argument to the required property\n\n        Args:\n            reinitialize: initialize size params to those created by\n                `get_size` after adjusting for\\ columns, fraction etc.\n            **kwargs: flexible keyword arguments specified by the user,\n                where the name of \\\n        the argument is the key and the offset is the value.\n        \"\"\"\n        self.sizer.update_textsize(reinitialize=reinitialize, **kwargs)\n\n\n    def update_textweight(self, reinitialize=False, **kwargs):\n\"\"\"This function changes the font weight of various text elements in the plot such as xlabel, \\\n        ylabel, title. The values are 'light', 'normal', 'bold'.\n        Uses deterministic and probabilistic matching to determine and map the keyword\n        \\ argument to the required property\n\n        Args:\n            reinitialize: initialize size params to those created by\n                `get_size` after adjusting for\\ columns, fraction etc.\n            **kwargs: flexible keyword arguments specified by the user,\n                where the name of \\\n        the argument is the key and the weight is the value.\n        \"\"\"\n        self.sizer.update_textweight(reinitialize=reinitialize, **kwargs)\n\n\n    def remove_ticks(self, xtick=True, ytick=True):\n\"\"\"remove the tick marks\n\n        Args:\n            xtick: remove ticks on x-axis, defaults to True\n            ytick: remove ticks on y-axis, defaults to True\n        \"\"\"\n        self.sizer.remove_ticks(xtick=xtick, ytick=ytick)\n\n\n    def set_lim(self, ax, xlims=(None, None), ylims=(None, None)):\n\"\"\"set the starting and ending points of the x and y axes\n\n        Args:\n            ax: the matplotlib axis object\n            xlims: tuple containing the (min, max) values of the \\ x\n                axis, defaults to (None, None)\n            ylims: tuple containing the (min, max) values of the \\ y\n                axis, defaults to (None, None)\n        \"\"\"\n        if xlims[0] is not None and xlims[1] is not None:\n            ax.set_xlim(xlims[0], xlims[1])\n        if ylims[0] is not None and ylims[1] is not None:\n            ax.set_ylim(ylims[0], ylims[1])\n\n\n    @copy_docstring(set_text)\n    def set_text(self, plt=None, ax=None, xlabel=None, ylabel=None, title=None, xticklocs=None, xticklabels=None,\n               xtickrot=None, yticklocs=None, yticklabels=None, ytickrot=None):\n        set_text(plt=plt, ax=ax, xlabel=xlabel, ylabel=ylabel, title=title, xticklocs=xticklocs, xticklabels=xticklabels,\n               xtickrot=xtickrot, yticklocs=yticklocs, yticklabels=yticklabels, ytickrot=ytickrot)\n\n\n    @copy_docstring(save)\n    def save(self, save_path, fig=None, plt=None, format='pdf'):\n        save(save_path, fig=fig, plt=plt, format=format)\n</code></pre>"},{"location":"api/#plotex.main.Plotex.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>initialize the controller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>parameters for the config file, the params include <code>url</code>         (the url for the config file), <code>cmap/palette</code> for the cmap, <code>style/theme</code>         for the seaborn style</p> <code>{}</code> Source code in <code>plotex/main.py</code> <pre><code>def __init__(self, **kwargs):\n\"\"\"initialize the controller\n\n    Args:\n        **kwargs: parameters for the config file, the params include\n            `url` \\\n    (the url for the config file), `cmap/palette` for the cmap, `style/theme` \\\n    for the seaborn style\n    \"\"\"\n    init = kwargs.get('initialize', True)\n    if init:\n        self.init(**kwargs)\n</code></pre>"},{"location":"api/#plotex.main.Plotex.init","title":"<code>init(**kwargs)</code>","text":"<p>initialize the controller</p> <p>Parameters:</p> Name Type Description Default <code>**kwargs</code> <p>parameters for the config file, the params include <code>url</code>         (the url for the config file), <code>cmap/palette</code> for the cmap, <code>style/theme</code>         for the seaborn style</p> <code>{}</code> Source code in <code>plotex/main.py</code> <pre><code>def init(self, **kwargs):\n\"\"\"initialize the controller\n\n    Args:\n        **kwargs: parameters for the config file, the params include\n            `url` \\\n    (the url for the config file), `cmap/palette` for the cmap, `style/theme` \\\n    for the seaborn style\n    \"\"\"\n    self.config = BackendConfiguration(**kwargs)\n    self.sizer = Sizing(config=self.config)\n    self.params = None\n    self.config.initialize()\n</code></pre>"},{"location":"api/#plotex.main.Plotex.remove_ticks","title":"<code>remove_ticks(xtick=True, ytick=True)</code>","text":"<p>remove the tick marks</p> <p>Parameters:</p> Name Type Description Default <code>xtick</code> <p>remove ticks on x-axis, defaults to True</p> <code>True</code> <code>ytick</code> <p>remove ticks on y-axis, defaults to True</p> <code>True</code> Source code in <code>plotex/main.py</code> <pre><code>def remove_ticks(self, xtick=True, ytick=True):\n\"\"\"remove the tick marks\n\n    Args:\n        xtick: remove ticks on x-axis, defaults to True\n        ytick: remove ticks on y-axis, defaults to True\n    \"\"\"\n    self.sizer.remove_ticks(xtick=xtick, ytick=ytick)\n</code></pre>"},{"location":"api/#plotex.main.Plotex.set_lim","title":"<code>set_lim(ax, xlims=(None, None), ylims=(None, None))</code>","text":"<p>set the starting and ending points of the x and y axes</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <p>the matplotlib axis object</p> required <code>xlims</code> <p>tuple containing the (min, max) values of the \\ x axis, defaults to (None, None)</p> <code>(None, None)</code> <code>ylims</code> <p>tuple containing the (min, max) values of the \\ y axis, defaults to (None, None)</p> <code>(None, None)</code> Source code in <code>plotex/main.py</code> <pre><code>def set_lim(self, ax, xlims=(None, None), ylims=(None, None)):\n\"\"\"set the starting and ending points of the x and y axes\n\n    Args:\n        ax: the matplotlib axis object\n        xlims: tuple containing the (min, max) values of the \\ x\n            axis, defaults to (None, None)\n        ylims: tuple containing the (min, max) values of the \\ y\n            axis, defaults to (None, None)\n    \"\"\"\n    if xlims[0] is not None and xlims[1] is not None:\n        ax.set_xlim(xlims[0], xlims[1])\n    if ylims[0] is not None and ylims[1] is not None:\n        ax.set_ylim(ylims[0], ylims[1])\n</code></pre>"},{"location":"api/#plotex.main.Plotex.skeleton","title":"<code>skeleton(width=None, publisher=None, width_in_pts=True, reinitialize=True, fraction=1, subplots=(1, 1), **kwargs)</code>","text":"<p>finds the ideal size of the plot and adjusts the text sizes according to the required dimensions this is a dummy function wrapped over the <code>get_figure</code> function from Sizing to enable direct access</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <p>the width, defaults to None</p> <code>None</code> <code>publisher</code> <p>the name of the publisher, defaults to None</p> <code>None</code> <code>width_in_pts</code> <p>whether the width is in points, defaults to True</p> <code>True</code> <code>reinitialize</code> <p>whether to reinitialize the config to itys defaults, defaults to True</p> <code>True</code> <code>fraction</code> <p>the fraction of the width supplied to use, defaults to 1</p> <code>1</code> <code>subplots</code> <p>(nrows, ncols), defaults to (1, 1)</p> <code>(1, 1)</code> <p>Returns:</p> Type Description <p>fig, axes if return_size is False, else (width, height)</p> Source code in <code>plotex/main.py</code> <pre><code>def skeleton(self, width=None, publisher=None, width_in_pts=True, reinitialize=True, fraction=1, \n               subplots=(1, 1), **kwargs):\n\"\"\"finds the ideal size of the plot and adjusts the text sizes according to the required dimensions\n    this is a dummy function wrapped over the `get_figure` function from Sizing to enable direct access\n\n    Args:\n        width: the width, defaults to None\n        publisher: the name of the publisher, defaults to None\n        width_in_pts: whether the width is in points, defaults to\n            True\n        reinitialize: whether to reinitialize the config to itys\n            defaults, defaults to True\n        fraction: the fraction of the width supplied to use,\n            defaults to 1\n        subplots: (nrows, ncols), defaults to (1, 1)\n\n    Returns:\n        fig, axes if return_size is False, else (width, height)\n    \"\"\"\n\n    output = self.sizer.get_size(width=width, publisher=publisher, width_in_pts=width_in_pts, reinitialize=reinitialize,\n                          fraction=fraction, subplots=subplots, **kwargs)\n    self.params = plt.rcParams.copy()\n    return output\n</code></pre>"},{"location":"api/#plotex.main.Plotex.update_textsize","title":"<code>update_textsize(reinitialize=True, **kwargs)</code>","text":"<p>This function changes the font size of various text elements in the plot such as xlabel,         ylabel, title, ticks, etc., by a specified offset. Uses deterministic and probabilistic         matching to determine and map the keyword argument to the required property</p> <p>Parameters:</p> Name Type Description Default <code>reinitialize</code> <p>initialize size params to those created by <code>get_size</code> after adjusting for\\ columns, fraction etc.</p> <code>True</code> <code>**kwargs</code> <p>flexible keyword arguments specified by the user, where the name of         the argument is the key and the offset is the value.</p> <code>{}</code> Source code in <code>plotex/main.py</code> <pre><code>def update_textsize(self, reinitialize=True, **kwargs):\n\"\"\"This function changes the font size of various text elements in the plot such as xlabel, \\\n    ylabel, title, ticks, etc., by a specified offset. Uses deterministic and probabilistic \\\n    matching to determine and map the keyword argument to the required property\n\n    Args:\n        reinitialize: initialize size params to those created by\n            `get_size` after adjusting for\\ columns, fraction etc.\n        **kwargs: flexible keyword arguments specified by the user,\n            where the name of \\\n    the argument is the key and the offset is the value.\n    \"\"\"\n    self.sizer.update_textsize(reinitialize=reinitialize, **kwargs)\n</code></pre>"},{"location":"api/#plotex.main.Plotex.update_textweight","title":"<code>update_textweight(reinitialize=False, **kwargs)</code>","text":"<p>This function changes the font weight of various text elements in the plot such as xlabel,         ylabel, title. The values are 'light', 'normal', 'bold'. Uses deterministic and probabilistic matching to determine and map the keyword \\ argument to the required property</p> <p>Parameters:</p> Name Type Description Default <code>reinitialize</code> <p>initialize size params to those created by <code>get_size</code> after adjusting for\\ columns, fraction etc.</p> <code>False</code> <code>**kwargs</code> <p>flexible keyword arguments specified by the user, where the name of         the argument is the key and the weight is the value.</p> <code>{}</code> Source code in <code>plotex/main.py</code> <pre><code>def update_textweight(self, reinitialize=False, **kwargs):\n\"\"\"This function changes the font weight of various text elements in the plot such as xlabel, \\\n    ylabel, title. The values are 'light', 'normal', 'bold'.\n    Uses deterministic and probabilistic matching to determine and map the keyword\n    \\ argument to the required property\n\n    Args:\n        reinitialize: initialize size params to those created by\n            `get_size` after adjusting for\\ columns, fraction etc.\n        **kwargs: flexible keyword arguments specified by the user,\n            where the name of \\\n    the argument is the key and the weight is the value.\n    \"\"\"\n    self.sizer.update_textweight(reinitialize=reinitialize, **kwargs)\n</code></pre>"},{"location":"api/#plotex.plotsize","title":"<code>plotsize</code>","text":""},{"location":"api/#plotex.plotsize.figsize","title":"<code>figsize</code>","text":""},{"location":"api/#plotex.plotsize.figsize.Sizing","title":"<code>Sizing</code>","text":"Source code in <code>plotex/plotsize/figsize.py</code> <pre><code>class Sizing():\n\n    CONFIG_URL = 'https://gist.githubusercontent.com/rg089/92540eef5ee88de5d2770a453c85c489/raw/b127ba7b0e7eff3c5eddf1202f01595e5c60c949/size_config.json'\n    CONFIG_PATH = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"config_files/size_config.json\")\n\n\n    def __init__(self, config=None, **config_kwargs):\n\"\"\"initialize the sizing class\n\n        Args:\n            config: the config file, defaults to None\n        \"\"\"\n        self.config = config\n        if self.config is None:\n            self.config = BackendConfiguration(**config_kwargs)\n            self.config.initialize()\n        self.params = None\n        self.size_config = self.__load_config()\n\n\n    def __load_config(self):\n        if os.path.exists(Sizing.CONFIG_PATH):\n            with open(Sizing.CONFIG_PATH, 'r') as f:\n                config = json.load(f)\n        else:\n            r = requests.get(Sizing.CONFIG_URL)\n            config = r.json()\n            save_file(content=config, fpath=Sizing.CONFIG_PATH)\n\n        return config\n\n\n    def __save_params(self):\n\"\"\"save a copy of the current rcParams\"\"\"\n        self.params = plt.rcParams.copy()\n\n\n    def __load_params(self):\n\"\"\"load the current saved copy of the rcParams\"\"\"\n        if self.params is not None:\n            plt.rcParams.update(self.params)\n\n\n    def __get_width_publisher(self, publisher, width=None):\n\"\"\"get the width in pts given the name of the publisher\n\n        Args:\n            publisher (str): the name of the publisher\n            width (float): if width is specified, then it is cached\n\n        Returns:\n            float: the width in pts\n        \"\"\"\n        publisher = publisher.lower()\n\n        if width is not None:\n            self.__cache_width(publisher, width)\n            return width\n\n        width = self.__read_width(publisher)\n\n        return width\n\n\n    def __read_width(self, publisher:str):\n\"\"\"\n        reads the width from the config file for the supplied publisher. \\\n        If not found, then use the ACL format width\n\n        Args:\n            publisher (str): the publisher name\n\n        Returns:\n            float: the width in pts\n        \"\"\"\n        if publisher in self.size_config['width']:\n            width = self.size_config['width'][publisher]\n        else:\n            print(f'[INFO] Publisher \"{publisher}\" not found, setting to ACL format!')\n            print('To save this publisher, give the values for both publisher and width')\n            width = 455.244\n\n        return width\n\n\n    def __cache_width(self, publisher:str, width:float):\n\"\"\"\n        caches the `publisher:width` mapping \n\n        Args:\n            publisher (str): the publisher\n            width (float): the width in pts\n        \"\"\"\n        print(f'[INFO] Caching {publisher}:{width} mapping!')\n        self.size_config['width'][publisher] = width\n        save_file(self.size_config, Sizing.CONFIG_PATH)\n\n\n    def adjust_font_size(self, subplots, fraction, **kwargs):\n\"\"\"adjust the font_size based on the fraction and number of columns and\n        saves the adjusted params\n\n        Args:\n            subplots: at uple of (nrow, ncols)\n            fraction: fraction of the total width to use\n        \"\"\"\n        _, num_cols = subplots\n\n        font_params = ['font.size', 'axes.titlesize', 'legend.title_fontsize', 'xtick.labelsize', 'ytick.labelsize', 'axes.labelsize', 'legend.fontsize']\n        for param in font_params:\n            curr_value = float(plt.rcParams[param])\n            plt.rcParams[param] = math.ceil(curr_value/num_cols*fraction)\n        self.__save_params()\n\n\n    def __find_matching_param(self, key, main_params, special_params={}):\n\"\"\"find the matching paramater to the key in the matplotlib.rcParams file specified by\n        the main_params and special_params\n\n        Args:\n            key: the key with which we search\n            main_params: the main dictionary, with keys as rcParams keys\n                and values as their shortened versions\n            special_params: direct mapping to handle exceptions where\n                probabilstic matching might fail, defaults to {}\n\n        Returns:\n            the found parameter, or None if not found\n        \"\"\"\n        all_matches = list(main_params.keys()) + list(main_params.values()) # Search over both keys and values\n\n        if key in special_params:\n            parameter = special_params[key]\n        else:\n            parameter = difflib.get_close_matches(key, all_matches, n=1)\n\n            if not parameter:\n                print(f\"[INFO] No match found for argument: {key}!\")\n                return None\n\n            parameter = parameter[0]\n\n            if parameter not in main_params:\n                parameter = [k for k, v in main_params.items() if v == parameter][0]\n\n        return parameter\n\n\n    def update_textsize(self, reinitialize=True, **kwargs):\n\"\"\"This function changes the font size of various text elements in the plot such as xlabel,\n        ylabel, title, sticks, etc., by a specified offset. Uses deterministic and probabilistic\n        matching to determine and map the keyword argument to the required property\n\n        Args:\n            reinitialize: initialize size params to those created by\n                `get_size` after adjusting for columns, fraction etc.\n            **kwargs: flexible keyword arguments specified by the user,\n                where the name of\n        the argument is the key and the offset is the value.\n        \"\"\"\n        if reinitialize:\n            self.__load_params()\n\n        font_params = {'font.size': 'fontsize',\n                    'axes.titlesize': 'title',\n                    'legend.title_fontsize': 'legendtitle',\n                    'xtick.labelsize': 'xticks',\n                    'ytick.labelsize': 'yticks',\n                    'axes.labelsize': 'labels',\n                    'legend.fontsize': 'legend'}\n\n        special_params = {'xlabel': 'axes.labelsize', 'ylabel': 'axes.labelsize', \n                          'title': 'axes.titlesize', 'legend': 'legend.fontsize'}\n\n        for key, value in kwargs.items():\n            font_param = self.__find_matching_param(key=key, main_params=font_params, \n                                                    special_params=special_params)\n            if font_param is None: continue\n            current_size = plt.rcParams[font_param]\n            plt.rcParams[font_param] = current_size + value\n\n\n    def update_textweight(self, reinitialize=False, **kwargs):\n\"\"\"This function changes the font weight of various text elements in the plot such as xlabel,\n        ylabel, title. The values are 'light', 'normal', 'bold'.\n        Uses deterministic and probabilistic matching to determine and map the keyword\n        argument to the required property\n\n        Args:\n            reinitialize: initialize size params to those created by\n                `get_size` after adjusting for columns, fraction etc.\n            **kwargs: flexible keyword arguments specified by the user,\n                where the name of\n        the argument is the key and the weight is the value.\n        \"\"\"\n        if reinitialize:\n            self.__load_params()\n\n        font_params = {\n                    'axes.titleweight': 'title',\n                    'axes.labelweight': 'label'}\n\n        special_params = {'xlabel': 'axes.labelweight', 'ylabel': 'axes.labelweight', \n                          'title': 'axes.titlweight'}\n\n        for key, value in kwargs.items():\n            font_param = self.__find_matching_param(key, main_params=font_params, \n                                                    special_params=special_params)\n            if font_param is None: continue            \n            plt.rcParams[font_param] = value\n\n\n    def remove_ticks(self, xtick=True, ytick=True):\n\"\"\"remove the tick marks\n\n        Args:\n            xtick: remove ticks on x-axis, defaults to True\n            ytick: remove ticks on y-axis, defaults to True\n        \"\"\"\n        if xtick:\n            plt.rcParams['xtick.major.size'] = 0\n        if ytick:\n            plt.rcParams['ytick.major.size'] = 0\n\n\n    def set_lim(self, ax, xlims=(None, None), ylims=(None, None)):\n\"\"\"set the starting and ending points of the x and y axes\n\n        Args:\n            ax: the matplotlib axis object\n            xlims: tuple containing the (min, max) values of the x\n                axis, defaults to (None, None)\n            ylims: tuple containing the (min, max) values of the y\n                axis, defaults to (None, None)\n        \"\"\"\n        if xlims[0] is not None and xlims[1] is not None:\n            ax.set_xlim(xlims[0], xlims[1])\n        if ylims[0] is not None and ylims[1] is not None:\n            ax.set_ylim(ylims[0], ylims[1])\n\n\n    def convert_width_to_inches(self, width=None, publisher=None):\n\"\"\"convert width from pts to inches\n\n        Args:\n            width: the given width in pts, defaults to None\n            publisher: the name of the publisher, defaults to None\n\n        Returns:\n            the width in inches\n        \"\"\"\n        if publisher is not None:\n            width_pt = self.__get_width_publisher(publisher=publisher, width=width)\n        else:\n            width_pt = width \n        fig_width_pt = width_pt \n        inches_per_pt = 1 / 72.27\n\n        fig_width_in = fig_width_pt * inches_per_pt\n        return fig_width_in\n\n\n    def get_size(self, width=None, publisher=None, width_in_pts=True, reinitialize=True, fraction=1, \n                   subplots=(1, 1), **kwargs):\n\"\"\"finds the ideal size of the plot and adjusts the text sizes according to the required dimensions\n            if both publisher and width are specified, then the publisher:width is cached\n\n        Args:\n            width: the width, defaults to None\n            publisher: the name of the publisher, defaults to None\n            width_in_pts: whether the width is in points, defaults to\n                True\n            reinitialize: whether to reinitialize the config to itys\n                defaults, defaults to True\n            fraction: the fraction of the width supplied to use,\n                defaults to 1\n            subplots: (nrows, ncols), defaults to (1, 1)\n\n        Returns:\n            figsize (width, height)\n        \"\"\"\n        assert publisher is not None or width is not None, \"Either set the width or the format.\"\n\n        if reinitialize: self.config.initialize()\n\n        golden_ratio = (5**.5 - 1) / 2\n\n        if width_in_pts:\n            fig_width_in = self.convert_width_to_inches(width=width, publisher=publisher)\n        else:\n            fig_width_in = width\n\n        fig_width_in *= fraction\n        fig_height_in = fig_width_in * golden_ratio * (subplots[0] / subplots[1])\n\n        self.adjust_font_size(subplots=subplots, fraction=fraction, **kwargs)\n\n        return (fig_width_in, fig_height_in)\n</code></pre>"},{"location":"api/#plotex.plotsize.figsize.Sizing.__cache_width","title":"<code>__cache_width(publisher, width)</code>","text":"<p>caches the <code>publisher:width</code> mapping </p> <p>Parameters:</p> Name Type Description Default <code>publisher</code> <code>str</code> <p>the publisher</p> required <code>width</code> <code>float</code> <p>the width in pts</p> required Source code in <code>plotex/plotsize/figsize.py</code> <pre><code>def __cache_width(self, publisher:str, width:float):\n\"\"\"\n    caches the `publisher:width` mapping \n\n    Args:\n        publisher (str): the publisher\n        width (float): the width in pts\n    \"\"\"\n    print(f'[INFO] Caching {publisher}:{width} mapping!')\n    self.size_config['width'][publisher] = width\n    save_file(self.size_config, Sizing.CONFIG_PATH)\n</code></pre>"},{"location":"api/#plotex.plotsize.figsize.Sizing.__find_matching_param","title":"<code>__find_matching_param(key, main_params, special_params={})</code>","text":"<p>find the matching paramater to the key in the matplotlib.rcParams file specified by the main_params and special_params</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <p>the key with which we search</p> required <code>main_params</code> <p>the main dictionary, with keys as rcParams keys and values as their shortened versions</p> required <code>special_params</code> <p>direct mapping to handle exceptions where probabilstic matching might fail, defaults to {}</p> <code>{}</code> <p>Returns:</p> Type Description <p>the found parameter, or None if not found</p> Source code in <code>plotex/plotsize/figsize.py</code> <pre><code>def __find_matching_param(self, key, main_params, special_params={}):\n\"\"\"find the matching paramater to the key in the matplotlib.rcParams file specified by\n    the main_params and special_params\n\n    Args:\n        key: the key with which we search\n        main_params: the main dictionary, with keys as rcParams keys\n            and values as their shortened versions\n        special_params: direct mapping to handle exceptions where\n            probabilstic matching might fail, defaults to {}\n\n    Returns:\n        the found parameter, or None if not found\n    \"\"\"\n    all_matches = list(main_params.keys()) + list(main_params.values()) # Search over both keys and values\n\n    if key in special_params:\n        parameter = special_params[key]\n    else:\n        parameter = difflib.get_close_matches(key, all_matches, n=1)\n\n        if not parameter:\n            print(f\"[INFO] No match found for argument: {key}!\")\n            return None\n\n        parameter = parameter[0]\n\n        if parameter not in main_params:\n            parameter = [k for k, v in main_params.items() if v == parameter][0]\n\n    return parameter\n</code></pre>"},{"location":"api/#plotex.plotsize.figsize.Sizing.__get_width_publisher","title":"<code>__get_width_publisher(publisher, width=None)</code>","text":"<p>get the width in pts given the name of the publisher</p> <p>Parameters:</p> Name Type Description Default <code>publisher</code> <code>str</code> <p>the name of the publisher</p> required <code>width</code> <code>float</code> <p>if width is specified, then it is cached</p> <code>None</code> <p>Returns:</p> Name Type Description <code>float</code> <p>the width in pts</p> Source code in <code>plotex/plotsize/figsize.py</code> <pre><code>def __get_width_publisher(self, publisher, width=None):\n\"\"\"get the width in pts given the name of the publisher\n\n    Args:\n        publisher (str): the name of the publisher\n        width (float): if width is specified, then it is cached\n\n    Returns:\n        float: the width in pts\n    \"\"\"\n    publisher = publisher.lower()\n\n    if width is not None:\n        self.__cache_width(publisher, width)\n        return width\n\n    width = self.__read_width(publisher)\n\n    return width\n</code></pre>"},{"location":"api/#plotex.plotsize.figsize.Sizing.__init__","title":"<code>__init__(config=None, **config_kwargs)</code>","text":"<p>initialize the sizing class</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <p>the config file, defaults to None</p> <code>None</code> Source code in <code>plotex/plotsize/figsize.py</code> <pre><code>def __init__(self, config=None, **config_kwargs):\n\"\"\"initialize the sizing class\n\n    Args:\n        config: the config file, defaults to None\n    \"\"\"\n    self.config = config\n    if self.config is None:\n        self.config = BackendConfiguration(**config_kwargs)\n        self.config.initialize()\n    self.params = None\n    self.size_config = self.__load_config()\n</code></pre>"},{"location":"api/#plotex.plotsize.figsize.Sizing.__load_params","title":"<code>__load_params()</code>","text":"<p>load the current saved copy of the rcParams</p> Source code in <code>plotex/plotsize/figsize.py</code> <pre><code>def __load_params(self):\n\"\"\"load the current saved copy of the rcParams\"\"\"\n    if self.params is not None:\n        plt.rcParams.update(self.params)\n</code></pre>"},{"location":"api/#plotex.plotsize.figsize.Sizing.__read_width","title":"<code>__read_width(publisher)</code>","text":"<p>reads the width from the config file for the supplied publisher.         If not found, then use the ACL format width</p> <p>Parameters:</p> Name Type Description Default <code>publisher</code> <code>str</code> <p>the publisher name</p> required <p>Returns:</p> Name Type Description <code>float</code> <p>the width in pts</p> Source code in <code>plotex/plotsize/figsize.py</code> <pre><code>def __read_width(self, publisher:str):\n\"\"\"\n    reads the width from the config file for the supplied publisher. \\\n    If not found, then use the ACL format width\n\n    Args:\n        publisher (str): the publisher name\n\n    Returns:\n        float: the width in pts\n    \"\"\"\n    if publisher in self.size_config['width']:\n        width = self.size_config['width'][publisher]\n    else:\n        print(f'[INFO] Publisher \"{publisher}\" not found, setting to ACL format!')\n        print('To save this publisher, give the values for both publisher and width')\n        width = 455.244\n\n    return width\n</code></pre>"},{"location":"api/#plotex.plotsize.figsize.Sizing.__save_params","title":"<code>__save_params()</code>","text":"<p>save a copy of the current rcParams</p> Source code in <code>plotex/plotsize/figsize.py</code> <pre><code>def __save_params(self):\n\"\"\"save a copy of the current rcParams\"\"\"\n    self.params = plt.rcParams.copy()\n</code></pre>"},{"location":"api/#plotex.plotsize.figsize.Sizing.adjust_font_size","title":"<code>adjust_font_size(subplots, fraction, **kwargs)</code>","text":"<p>adjust the font_size based on the fraction and number of columns and saves the adjusted params</p> <p>Parameters:</p> Name Type Description Default <code>subplots</code> <p>at uple of (nrow, ncols)</p> required <code>fraction</code> <p>fraction of the total width to use</p> required Source code in <code>plotex/plotsize/figsize.py</code> <pre><code>def adjust_font_size(self, subplots, fraction, **kwargs):\n\"\"\"adjust the font_size based on the fraction and number of columns and\n    saves the adjusted params\n\n    Args:\n        subplots: at uple of (nrow, ncols)\n        fraction: fraction of the total width to use\n    \"\"\"\n    _, num_cols = subplots\n\n    font_params = ['font.size', 'axes.titlesize', 'legend.title_fontsize', 'xtick.labelsize', 'ytick.labelsize', 'axes.labelsize', 'legend.fontsize']\n    for param in font_params:\n        curr_value = float(plt.rcParams[param])\n        plt.rcParams[param] = math.ceil(curr_value/num_cols*fraction)\n    self.__save_params()\n</code></pre>"},{"location":"api/#plotex.plotsize.figsize.Sizing.convert_width_to_inches","title":"<code>convert_width_to_inches(width=None, publisher=None)</code>","text":"<p>convert width from pts to inches</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <p>the given width in pts, defaults to None</p> <code>None</code> <code>publisher</code> <p>the name of the publisher, defaults to None</p> <code>None</code> <p>Returns:</p> Type Description <p>the width in inches</p> Source code in <code>plotex/plotsize/figsize.py</code> <pre><code>def convert_width_to_inches(self, width=None, publisher=None):\n\"\"\"convert width from pts to inches\n\n    Args:\n        width: the given width in pts, defaults to None\n        publisher: the name of the publisher, defaults to None\n\n    Returns:\n        the width in inches\n    \"\"\"\n    if publisher is not None:\n        width_pt = self.__get_width_publisher(publisher=publisher, width=width)\n    else:\n        width_pt = width \n    fig_width_pt = width_pt \n    inches_per_pt = 1 / 72.27\n\n    fig_width_in = fig_width_pt * inches_per_pt\n    return fig_width_in\n</code></pre>"},{"location":"api/#plotex.plotsize.figsize.Sizing.get_size","title":"<code>get_size(width=None, publisher=None, width_in_pts=True, reinitialize=True, fraction=1, subplots=(1, 1), **kwargs)</code>","text":"<p>finds the ideal size of the plot and adjusts the text sizes according to the required dimensions     if both publisher and width are specified, then the publisher:width is cached</p> <p>Parameters:</p> Name Type Description Default <code>width</code> <p>the width, defaults to None</p> <code>None</code> <code>publisher</code> <p>the name of the publisher, defaults to None</p> <code>None</code> <code>width_in_pts</code> <p>whether the width is in points, defaults to True</p> <code>True</code> <code>reinitialize</code> <p>whether to reinitialize the config to itys defaults, defaults to True</p> <code>True</code> <code>fraction</code> <p>the fraction of the width supplied to use, defaults to 1</p> <code>1</code> <code>subplots</code> <p>(nrows, ncols), defaults to (1, 1)</p> <code>(1, 1)</code> <p>Returns:</p> Type Description <p>figsize (width, height)</p> Source code in <code>plotex/plotsize/figsize.py</code> <pre><code>def get_size(self, width=None, publisher=None, width_in_pts=True, reinitialize=True, fraction=1, \n               subplots=(1, 1), **kwargs):\n\"\"\"finds the ideal size of the plot and adjusts the text sizes according to the required dimensions\n        if both publisher and width are specified, then the publisher:width is cached\n\n    Args:\n        width: the width, defaults to None\n        publisher: the name of the publisher, defaults to None\n        width_in_pts: whether the width is in points, defaults to\n            True\n        reinitialize: whether to reinitialize the config to itys\n            defaults, defaults to True\n        fraction: the fraction of the width supplied to use,\n            defaults to 1\n        subplots: (nrows, ncols), defaults to (1, 1)\n\n    Returns:\n        figsize (width, height)\n    \"\"\"\n    assert publisher is not None or width is not None, \"Either set the width or the format.\"\n\n    if reinitialize: self.config.initialize()\n\n    golden_ratio = (5**.5 - 1) / 2\n\n    if width_in_pts:\n        fig_width_in = self.convert_width_to_inches(width=width, publisher=publisher)\n    else:\n        fig_width_in = width\n\n    fig_width_in *= fraction\n    fig_height_in = fig_width_in * golden_ratio * (subplots[0] / subplots[1])\n\n    self.adjust_font_size(subplots=subplots, fraction=fraction, **kwargs)\n\n    return (fig_width_in, fig_height_in)\n</code></pre>"},{"location":"api/#plotex.plotsize.figsize.Sizing.remove_ticks","title":"<code>remove_ticks(xtick=True, ytick=True)</code>","text":"<p>remove the tick marks</p> <p>Parameters:</p> Name Type Description Default <code>xtick</code> <p>remove ticks on x-axis, defaults to True</p> <code>True</code> <code>ytick</code> <p>remove ticks on y-axis, defaults to True</p> <code>True</code> Source code in <code>plotex/plotsize/figsize.py</code> <pre><code>def remove_ticks(self, xtick=True, ytick=True):\n\"\"\"remove the tick marks\n\n    Args:\n        xtick: remove ticks on x-axis, defaults to True\n        ytick: remove ticks on y-axis, defaults to True\n    \"\"\"\n    if xtick:\n        plt.rcParams['xtick.major.size'] = 0\n    if ytick:\n        plt.rcParams['ytick.major.size'] = 0\n</code></pre>"},{"location":"api/#plotex.plotsize.figsize.Sizing.set_lim","title":"<code>set_lim(ax, xlims=(None, None), ylims=(None, None))</code>","text":"<p>set the starting and ending points of the x and y axes</p> <p>Parameters:</p> Name Type Description Default <code>ax</code> <p>the matplotlib axis object</p> required <code>xlims</code> <p>tuple containing the (min, max) values of the x axis, defaults to (None, None)</p> <code>(None, None)</code> <code>ylims</code> <p>tuple containing the (min, max) values of the y axis, defaults to (None, None)</p> <code>(None, None)</code> Source code in <code>plotex/plotsize/figsize.py</code> <pre><code>def set_lim(self, ax, xlims=(None, None), ylims=(None, None)):\n\"\"\"set the starting and ending points of the x and y axes\n\n    Args:\n        ax: the matplotlib axis object\n        xlims: tuple containing the (min, max) values of the x\n            axis, defaults to (None, None)\n        ylims: tuple containing the (min, max) values of the y\n            axis, defaults to (None, None)\n    \"\"\"\n    if xlims[0] is not None and xlims[1] is not None:\n        ax.set_xlim(xlims[0], xlims[1])\n    if ylims[0] is not None and ylims[1] is not None:\n        ax.set_ylim(ylims[0], ylims[1])\n</code></pre>"},{"location":"api/#plotex.plotsize.figsize.Sizing.update_textsize","title":"<code>update_textsize(reinitialize=True, **kwargs)</code>","text":"<p>This function changes the font size of various text elements in the plot such as xlabel, ylabel, title, sticks, etc., by a specified offset. Uses deterministic and probabilistic matching to determine and map the keyword argument to the required property</p> <p>Parameters:</p> Name Type Description Default <code>reinitialize</code> <p>initialize size params to those created by <code>get_size</code> after adjusting for columns, fraction etc.</p> <code>True</code> <code>**kwargs</code> <p>flexible keyword arguments specified by the user, where the name of</p> <code>{}</code> <p>the argument is the key and the offset is the value.</p> Source code in <code>plotex/plotsize/figsize.py</code> <pre><code>def update_textsize(self, reinitialize=True, **kwargs):\n\"\"\"This function changes the font size of various text elements in the plot such as xlabel,\n    ylabel, title, sticks, etc., by a specified offset. Uses deterministic and probabilistic\n    matching to determine and map the keyword argument to the required property\n\n    Args:\n        reinitialize: initialize size params to those created by\n            `get_size` after adjusting for columns, fraction etc.\n        **kwargs: flexible keyword arguments specified by the user,\n            where the name of\n    the argument is the key and the offset is the value.\n    \"\"\"\n    if reinitialize:\n        self.__load_params()\n\n    font_params = {'font.size': 'fontsize',\n                'axes.titlesize': 'title',\n                'legend.title_fontsize': 'legendtitle',\n                'xtick.labelsize': 'xticks',\n                'ytick.labelsize': 'yticks',\n                'axes.labelsize': 'labels',\n                'legend.fontsize': 'legend'}\n\n    special_params = {'xlabel': 'axes.labelsize', 'ylabel': 'axes.labelsize', \n                      'title': 'axes.titlesize', 'legend': 'legend.fontsize'}\n\n    for key, value in kwargs.items():\n        font_param = self.__find_matching_param(key=key, main_params=font_params, \n                                                special_params=special_params)\n        if font_param is None: continue\n        current_size = plt.rcParams[font_param]\n        plt.rcParams[font_param] = current_size + value\n</code></pre>"},{"location":"api/#plotex.plotsize.figsize.Sizing.update_textweight","title":"<code>update_textweight(reinitialize=False, **kwargs)</code>","text":"<p>This function changes the font weight of various text elements in the plot such as xlabel, ylabel, title. The values are 'light', 'normal', 'bold'. Uses deterministic and probabilistic matching to determine and map the keyword argument to the required property</p> <p>Parameters:</p> Name Type Description Default <code>reinitialize</code> <p>initialize size params to those created by <code>get_size</code> after adjusting for columns, fraction etc.</p> <code>False</code> <code>**kwargs</code> <p>flexible keyword arguments specified by the user, where the name of</p> <code>{}</code> <p>the argument is the key and the weight is the value.</p> Source code in <code>plotex/plotsize/figsize.py</code> <pre><code>def update_textweight(self, reinitialize=False, **kwargs):\n\"\"\"This function changes the font weight of various text elements in the plot such as xlabel,\n    ylabel, title. The values are 'light', 'normal', 'bold'.\n    Uses deterministic and probabilistic matching to determine and map the keyword\n    argument to the required property\n\n    Args:\n        reinitialize: initialize size params to those created by\n            `get_size` after adjusting for columns, fraction etc.\n        **kwargs: flexible keyword arguments specified by the user,\n            where the name of\n    the argument is the key and the weight is the value.\n    \"\"\"\n    if reinitialize:\n        self.__load_params()\n\n    font_params = {\n                'axes.titleweight': 'title',\n                'axes.labelweight': 'label'}\n\n    special_params = {'xlabel': 'axes.labelweight', 'ylabel': 'axes.labelweight', \n                      'title': 'axes.titlweight'}\n\n    for key, value in kwargs.items():\n        font_param = self.__find_matching_param(key, main_params=font_params, \n                                                special_params=special_params)\n        if font_param is None: continue            \n        plt.rcParams[font_param] = value\n</code></pre>"},{"location":"api/#plotex.utils","title":"<code>utils</code>","text":""},{"location":"api/#plotex.utils.general","title":"<code>general</code>","text":""},{"location":"api/#plotex.utils.general.check_if_exists","title":"<code>check_if_exists(fpath)</code>","text":"<p>checks if fpath exists</p> <p>Parameters:</p> Name Type Description Default <code>fpath</code> <code>str</code> <p>the file path to check</p> required <p>:return bool: whether the path exists</p> Source code in <code>plotex/utils/general.py</code> <pre><code>def check_if_exists(fpath):\n\"\"\"checks if fpath exists\n\n    Args:\n        fpath (str): the file path to check\n    :return bool: whether the path exists\n    \"\"\"\n    return os.path.exists(fpath)\n</code></pre>"},{"location":"api/#plotex.utils.general.combine_hash","title":"<code>combine_hash(fpath, hashed)</code>","text":"<p>combines the file name with the hashcode and returns the absolute path</p> <p>Parameters:</p> Name Type Description Default <code>fpath</code> <p>fpath</p> required <code>hashed</code> <p>ahash code</p> required <p>Returns:</p> Type Description <p>the absolute combine path</p> Source code in <code>plotex/utils/general.py</code> <pre><code>def combine_hash(fpath, hashed):\n\"\"\"combines the file name with the hashcode and returns the absolute path\n\n    Args:\n        fpath: fpath\n        hashed: ahash code\n\n    Returns:\n        the absolute combine path\n    \"\"\"\n    assert fpath.endswith('.txt')\n\n    stripped_path = fpath.rstrip('.txt')\n    final_path = f\"{stripped_path}_{hashed}.txt\"\n    final_path = os.path.abspath(final_path)\n\n    return final_path\n</code></pre>"},{"location":"api/#plotex.utils.general.find_value_from_keys","title":"<code>find_value_from_keys(main_dict, keys)</code>","text":"<p>traverses the specified key list, and if any key is found in the dictionary, returns the corresponding value, else None</p> <p>Parameters:</p> Name Type Description Default <code>main_dict</code> <p>the dictionary to search in</p> required <code>keys</code> <p>the list of keys</p> required <p>Returns:</p> Type Description <p>the value if found, else None</p> Source code in <code>plotex/utils/general.py</code> <pre><code>def find_value_from_keys(main_dict, keys):\n\"\"\"traverses the specified key list, and if any key is found in the dictionary,\n    returns the corresponding value, else None\n\n    Args:\n        main_dict: the dictionary to search in\n        keys: the list of keys\n\n    Returns:\n        the value if found, else None\n    \"\"\"\n    for key in keys:\n        if key in main_dict:\n            return main_dict[key]\n\n    return None\n</code></pre>"},{"location":"api/#plotex.utils.general.save","title":"<code>save(save_path, fig=None, plt=None, format='pdf')</code>","text":"<p>utility function to save the figure</p> <p>Parameters:</p> Name Type Description Default <code>save_path</code> <p>the save path for the figure (including the extension)</p> required <code>fig</code> <p>the figure object, defaults to None</p> <code>None</code> <code>plt</code> <p>the plt object, defaults to None</p> <code>None</code> <code>format</code> <p>the format of the output plot, defaults to 'pdf'</p> <code>'pdf'</code> Source code in <code>plotex/utils/general.py</code> <pre><code>def save(save_path, fig=None, plt=None, format='pdf'):\n\"\"\"utility function to save the figure\n\n    Args:\n        save_path: the save path for the figure (including the\n            extension)\n        fig: the figure object, defaults to None\n        plt: the plt object, defaults to None\n        format: the format of the output plot, defaults to 'pdf'\n    \"\"\"\n    assert fig is not None or plt is not None\n\n    if fig is not None:\n        fig.savefig(save_path, format=format)\n    if plt is not None:\n        plt.savefig(save_path, format=format)\n</code></pre>"},{"location":"api/#plotex.utils.general.save_file","title":"<code>save_file(content, fpath)</code>","text":"<p>saves the supplied content in a text file</p> <p>Parameters:</p> Name Type Description Default <code>content</code> <code>str/dict</code> <p>the content</p> required <code>fpath</code> <code>str</code> <p>the file path to save at</p> required Source code in <code>plotex/utils/general.py</code> <pre><code>def save_file(content, fpath):\n\"\"\"saves the supplied content in a text file\n\n    Args:\n        content (str/dict): the content\n        fpath (str): the file path to save at\n    \"\"\"\n    base_folder = os.path.dirname(fpath)\n    os.makedirs(base_folder, exist_ok=True)\n\n    if fpath.endswith('.json'):\n        with open(fpath, \"w\") as f:\n            json.dump(content, f)\n    else:\n        assert isinstance(content, str)\n        with open(fpath, \"w\") as f:\n            f.write(content)\n</code></pre>"},{"location":"api/#plotex.utils.hashing","title":"<code>hashing</code>","text":""},{"location":"api/#plotex.utils.hashing.hash_url","title":"<code>hash_url(url)</code>","text":"<p>generate a hash for the url</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <p>the url string</p> required <p>Returns:</p> Type Description <p>the generated hash</p> Source code in <code>plotex/utils/hashing.py</code> <pre><code>def hash_url(url):\n\"\"\"generate a hash for the url\n\n    Args:\n        url: the url string\n\n    Returns:\n        the generated hash\n    \"\"\"\n    # Take the hash of the URL\n    url_hash = hashlib.sha1(url.encode('utf-8')).hexdigest()\n    # Encode the hash in base64\n    file_name = base64.b64encode(url_hash.encode('utf-8')).decode('utf-8')\n    # Remove any characters that are not safe for use in a file name\n    file_name = file_name.replace('/', '_').replace('+', '-')\n    # Truncate the file name to a maximum length\n    file_name = file_name[:10]\n    return file_name\n</code></pre>"},{"location":"api/#plotex.utils.plotting","title":"<code>plotting</code>","text":""},{"location":"api/#plotex.utils.plotting.custom_legend","title":"<code>custom_legend(ax, text, xy=(0.5, 0.5), box=True, box_bgcolor=(1.0, 1, 1, 1), box_edgecolor=(0.0, 0.0, 0.0, 0.1))</code>","text":"<p>create a custom legend/text (without color strip)</p> <pre><code>Args:\n    ax: mpl axes object\n    text: the text to add (str or list); if list added with `\n</code></pre> <p>`         xy: the (x,y) offset fraction, relative to the BOTTOM-LEFT             point, defaults to (0.5, 0.5)         box: whether to add a bounding box, defaults to True         box_bgcolor: the background color of the box, defaults to (1.0,             1, 1, 1)         box_edgecolor: the edge color of the box, defaults to (0.0, 0.0,             0.0, 0.1)</p> <pre><code>Returns:\n    `ax`, the axis object\n</code></pre> Source code in <code>plotex/utils/plotting.py</code> <pre><code>def custom_legend(ax, text, xy=(0.5, 0.5), box=True, box_bgcolor=(1.0, 1, 1, 1),\n                  box_edgecolor=(0.0, 0.0, 0.0, 0.1)):\n\"\"\"create a custom legend/text (without color strip)\n\n    Args:\n        ax: mpl axes object\n        text: the text to add (str or list); if list added with `\\n`\n        xy: the (x,y) offset fraction, relative to the BOTTOM-LEFT\n            point, defaults to (0.5, 0.5)\n        box: whether to add a bounding box, defaults to True\n        box_bgcolor: the background color of the box, defaults to (1.0,\n            1, 1, 1)\n        box_edgecolor: the edge color of the box, defaults to (0.0, 0.0,\n            0.0, 0.1)\n\n    Returns:\n        `ax`, the axis object\n    \"\"\"\n\n    if isinstance(text, list):\n        text = '\\n'.join(text)\n\n    assert isinstance(text, str)\n\n    if box:\n        ax.annotate(text,\n                xy=xy, xycoords='axes fraction',\n                textcoords='offset points',\n                bbox=dict(boxstyle=\"round\", fc=box_bgcolor,\n                          ec=box_edgecolor))\n    else:\n        ax.annotate(text,\n                xy=xy, xycoords='axes fraction',\n                textcoords='offset points')\n\n    return ax\n</code></pre>"},{"location":"api/#plotex.utils.plotting.optimize_labels","title":"<code>optimize_labels(labels, values)</code>","text":"<p>optimizes the bar chart labels by interweaving the labels based on their length to minimize overlap</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <p>the original labels</p> required <code>values</code> <p>the original values</p> required <p>Returns:</p> Type Description <p>optimized labels, values</p> Source code in <code>plotex/utils/plotting.py</code> <pre><code>def optimize_labels(labels, values):\n\"\"\"optimizes the bar chart labels by interweaving the labels based on their length to minimize overlap\n\n    Args:\n        labels: the original labels\n        values: the original values\n\n    Returns:\n        optimized labels, values\n    \"\"\"\n    mapper = {l:v for l,v in zip(labels, values)}\n    sorted_labels = sorted(labels, key=len)\n\n    n = len(labels)\n    start, end = 0, n-1\n\n    final_labels = []\n\n    while end &gt;= start:\n        if end == start:\n            final_labels.append(sorted_labels[start])\n        else:\n            final_labels.append(sorted_labels[start])\n            final_labels.append(sorted_labels[end])\n        start += 1\n        end -= 1\n\n    final_values = [mapper[label] for label in final_labels]\n    return final_labels, final_values\n</code></pre>"},{"location":"api/#plotex.utils.plotting.set_text","title":"<code>set_text(plt=None, ax=None, xlabel=None, ylabel=None, title=None, xticklocs=None, xticklabels=None, xtickrot=None, yticklocs=None, yticklabels=None, ytickrot=None)</code>","text":"<p>set xlabel/ylabel/xticks/yticks/title (including rotation of ticks)</p> <p>Parameters:</p> Name Type Description Default <code>plt</code> <code>plt</code> <p>the matplotlib pyplot object</p> <code>None</code> <code>ax</code> <code>matplotlib.axes.Axes</code> <p>axis on which to label</p> <code>None</code> <code>xlabel</code> <p>the xlabel string, defaults to None</p> <code>None</code> <code>ylabel</code> <p>the ylabel string, defaults to None</p> <code>None</code> <code>title</code> <p>the title string, defaults to None</p> <code>None</code> <code>xticklocs</code> <p>the location of xticks, defaults to None</p> <code>None</code> <code>xticklabels</code> <p>the labels of xticks, defaults to None</p> <code>None</code> <code>xtickrot</code> <p>the rotation angle in degrees of xtick labels, defaults to None</p> <code>None</code> <code>yticklocs</code> <p>the location of yticks, defaults to None</p> <code>None</code> <code>yticklabels</code> <p>the labels of yticks, defaults to None</p> <code>None</code> <code>ytickrot</code> <p>the rotation angle in degrees of ytick labels, defaults to None</p> <code>None</code> Source code in <code>plotex/utils/plotting.py</code> <pre><code>def set_text(plt:plt=None, ax:matplotlib.axes.Axes=None, xlabel=None, ylabel=None, title=None, xticklocs=None, xticklabels=None,\n               xtickrot=None, yticklocs=None, yticklabels=None, ytickrot=None):\n\"\"\"set xlabel/ylabel/xticks/yticks/title (including rotation of ticks)\n\n    Args:\n        plt: the matplotlib pyplot object\n        ax: axis on which to label\n        xlabel: the xlabel string, defaults to None\n        ylabel: the ylabel string, defaults to None\n        title: the title string, defaults to None\n        xticklocs: the location of xticks, defaults to None\n        xticklabels: the labels of xticks, defaults to None\n        xtickrot: the rotation angle in degrees of xtick labels,\n            defaults to None\n        yticklocs: the location of yticks, defaults to None\n        yticklabels: the labels of yticks, defaults to None\n        ytickrot: the rotation angle in degrees of ytick labels,\n            defaults to None\n    \"\"\"\n\n    assert plt is not None or ax is not None\n\n    if xlabel is not None:\n        if ax is not None: ax.set_xlabel(xlabel)\n        elif plt is not None: plt.xlabel(xlabel)\n\n    if ylabel is not None:\n        if ax is not None: ax.set_ylabel(ylabel)\n        elif plt is not None: plt.ylabel(ylabel)\n\n    if title is not None:\n        if ax is not None: ax.set_title(title)\n        elif plt is not None: plt.title(title)\n\n    if xtickrot is not None:\n        if ax is not None: ax.tick_params(axis='x', rotation=xtickrot)\n        elif plt is not None: plt.xticks(rotation=xtickrot)\n\n    assert xticklabels is None or (xticklabels is not None and xticklocs is not None)\n    if xticklocs is not None:\n        if ax is not None: ax.set_xticks(xticklocs, labels=xticklabels)\n        elif plt is not None: plt.xticks(ticks=xticklocs, labels=xticklabels)\n\n    if ytickrot is not None:\n        if ax is not None: ax.tick_params(axis='y', rotation=ytickrot)\n        elif plt is not None: plt.yticks(rotation=ytickrot)\n\n    assert yticklabels is None or (yticklabels is not None and yticklocs is not None)\n    if yticklocs is not None:\n        if ax is not None: ax.set_yticks(yticklocs, labels=yticklabels)\n        elif plt is not None: plt.yticks(ticks=yticklocs, labels=yticklabels)\n</code></pre>"}]}